{
    "id": 10,
    "slug": "unreal-dll-in-practice-part-1-concepts-and-system-design",
    "content": "故事開始於我嘗試把一個第三方函式庫直接塞進 Unreal Plugin，結果完全不意外，專案瞬間炸裂。\n\n那一刻我才真正意識到：如果要把外部庫整合進 Unreal，又不想讓整個專案變成依賴地獄，勢必要找一個更乾淨、穩定、可維護的方式。\n\n於是我開始研究把第三方程式碼包成 **Wrapper DLL**——用一組簡單的 C 風格介面，把 Unreal 與外部世界隔離開來。選擇 C 介面的原因很單純：**C ABI 穩定、跨編譯器與跨語言都比較友善。**這種做法不但能保留效能，也能把 ABI、例外處理、記憶體管理等高風險問題鎖在 DLL 裡，讓 Plugin 的生命週期更可控、部署更輕鬆。\n\n也因為這次的踩雷經驗，我決定做一個完整的練習專案，採用「**第三方函式庫 → Wrapper DLL → Unreal Plugin**」的分層架構。從理解 DLL 的角色、建立一個簡單的第三方測試函式庫、將其包成 DLL，到最後在 Unreal Engine 中建立 Plugin 並成功呼叫 DLL 裡的功能，完整走一遍乾淨整合的流程。\n\n讓我們開始吧。\n\n# 所以，到底甚麼是 DLL?\n\n動態連結函式庫（Dynamic-Link Library，簡稱 **DLL**）是 Windows 用來封裝與共享程式碼的一種機制。你在電腦裡常看到的 `.dll`、`.ocx`、`.drv`，本質上都是同一類型的模組。\n\n它的核心概念其實很單純：**把可以重複使用的功能獨立編譯成一個檔案，需要時再由應用程式載入使用，而不必每個程式都複製一份。**\n\n這麼做的好處：\n\n- **節省記憶體與磁碟空間** —— 多個程式可以共用同一份程式碼。\n- **集中管理更新** —— 修正 DLL 的問題後，所有使用它的程式都能使用新的 DLL。\n\n如果要打個比方，DLL 有點像圖書館裡的一本書，很多人可以同時閱讀同一本書，就像很多程式可以同時載入同一個 DLL。\n\n不同的是，在看書的過程中，每個人都會在自己的筆記本上做筆記。對應到電腦的世界，作業系統會讓不同應用程式**共享同一份 DLL 的程式碼區段**，但每個程式仍然擁有**自己的資料與執行狀態**。\n\n也就是說，雖然程式碼是共用的，但執行時的記憶體與變數都是彼此獨立的。\n\n不過 DLL 也不是沒有缺點。早期的 Windows 因為缺乏完善的版本管理機制，只要多個軟體共用同一個 DLL，就很容易因為**版本不相容**、**安裝程式覆蓋掉系統 DLL**，或是**路徑解析錯誤**，讓原本運作正常的程式突然整批掛掉。這種因 DLL 共用而引發的連鎖災難，有一個非常貼切的名字： [DLL地獄（DLL Hell）](https://zh.wikipedia.org/zh-tw/DLL%E5%9C%B0%E7%8D%84)。\n\n## 有動態函示庫，那有靜態的嗎?\n\n既然有 DLL（動態連結函式庫），那也會有**靜態函式庫（Static Library）**。在 Windows 世界裡，它通常是 `.lib` 檔；在 Linux 則是 `.a` 檔。兩者最大的差別在於**程式碼是在什麼時候被放進你的應用程式裡**。\n\n靜態函式庫的運作方式很直接：在編譯階段，編譯器會把 `.lib` 裡需要的程式碼直接複製到你的可執行檔或 DLL 裡。這代表：\n\n- **編譯後的程式不需要額外的外部檔案，**給一個 `.exe` 就能跑。\n- 可執行檔會變大，且更新函式庫時需要重新編譯整個專案。\n\n> 💡 **想像你正在編寫一本書，而「函式庫」就是你引用的參考資料：**\n> \n\n### 靜態函式庫 (Static Lib)：影印店模式\n\n這就像是你去影印店，把整本參考書**全部複印下來，直接裝訂進你的書背後**。\n\n- **優點**：讀者買了你的書，翻到後面就能看資料（不需要額外帶書，部署簡單）。\n- **缺點**：你的書會變得很厚很重（執行檔變大）；如果原稿內容更新了，你得整本重新複印並重新裝訂（重新編譯整個專案）。\n\n### 動態函式庫 (DLL)：圖書館標註模式\n\n這就像是你只在書裡寫了一行註解：「請參考某某圖書館的某某書第 100 頁」。\n\n- **優點**：你的書很輕薄，且如果圖書館更新了更正確的書籍，你的書內容也隨之「升級」（集中管理更新）。\n- **缺點**：如果讀者家附近沒有那個圖書館，或者圖書館把書搬走了，你的書就沒法讀了（路徑錯誤或 DLL 遺失，導致程式崩潰）。\n\n### 混合模式 (.lib + .dll)：隨書附贈的導航地圖\n\n當你同時擁有這兩者時，`.lib` 就像是**隨書附贈的導航地圖（或精確索引）**。\n你不需要影印整本書，但你隨書附上一張精確的地圖。這張地圖（.lib）在編譯時會告訴你的程式：「書（代碼）確實存在，它的名字叫 `XXX.dll`，裡面有這些功能」。\n\n結果就是編譯器很放心（因為有地圖證明書存在），執行時系統也很輕鬆（因為有地圖引導去哪裡借書）。\n\n| **特性** | **純靜態函式庫 (只有大 .lib)** | **混合模式：隱式動態連結(小 .lib + .dll)** | **純動態：顯式動態連結(只有 .dll)** |\n| --- | --- | --- | --- |\n| **白話比喻** | **「影印店」**：內容直接印在書裡 | **「導航地圖」**：拿著地圖去圖書館借書 | **「盲找」**：到圖書館才打聽書在哪 |\n| **連結時間** | **編譯時** (Build Time) | **編譯時** (對地圖) + **執行時** (載入書) | **執行時** (Runtime)完全由程式碼手動控制 |\n| **程式碼位置** | **嵌入**在 `.exe` 內部 | **獨立**存在於外部 DLL 檔案 | **獨立**存在於外部 DLL 檔案 |\n| **部署難度** | **極低**：只有一個檔案 | **中等**：須確保 DLL 跟著 .exe | **中等**：須確保 DLL 跟著 .exe |\n| **更新方式** | **必須重新編譯**整個專案 | **直接換 DLL** 即可更新 | **直接換 DLL** |\n| **記憶體佔用** | **較高**：每個程式都含複本 | **較低**：多個程式共用內存 | **最靈活**：不用時可動態卸載 |\n| **開發難易度** | **易**：直接呼叫函式 | **易**：直接呼叫，編譯器會檢查 | **難**：需手動查位址、寫指標 |\n| **Unreal 常用度** | 常用於小型工具類 Plugin | **最常用**：主流 SDK 整合方式 | 進階：驅動、加密或熱更新模組 |\n\n## 為什麼不直接把第三方原始碼放進 Unreal Engine？\n\n雖然直接把別人的原始碼（Source Code）丟進專案資料夾看起來最省事，但在 Unreal Engine 這種充滿各種自定義的巨集的重量級巨獸面前，這種做法就像是想把一台法拉利的引擎直接焊接在卡車上，結果通常是車毀人亡。\n\n### 1. 命名空間的相互衝突\n\nUnreal 定義了大量的全域巨集（例如 `check()`, `TEXT()`, `Verify()`）。如果第三方原始碼（例如 Boost 或 ffmpeg）也定義了同名函式，編譯器會噴出幾千個錯誤訊息，你得花好幾週去改別人的程式碼才能相容。\n\n### 2. UHT 的理解障礙\n\nUE 的反射系統（讓藍圖能讀取 C++）依賴 UHT 掃描標頭檔。但 UHT 並不是真正的編譯器，它看不懂現代 C++ 太複雜的模板（Template）或語法糖。直接塞進去，UHT 會直接報錯罷工。\n\n### 3. 編譯時間考量\n\nUE 本身已經夠大了。如果你把一個幾萬行的第三方庫塞進專案，每次你改一個小功能，編譯器可能都要重新檢查那些沒動過的第三方代碼。\n\n- **使用 DLL 的解法**：DLL 是**預編譯好的二進位檔案**。對 UE 來說，它就像一個「黑盒子」，不需要重新編譯，只需要「連結」它。這能節省你每天幾小時的等待時間。\n\n## 結論：DLL 是一種隔離牆\n\n在開發中，通常會把第三方原始碼封裝成 DLL，這本質上是在 Unreal 與外部程式碼之間蓋起一道防護牆：\n\n- **牆內（DLL 內部）：** 你愛怎麼寫就怎麼寫，語法再怪、跟 UE 命名衝突都沒關係，它是一個獨立運作的黑盒子。\n- **牆外（UE 專案）：** 透過那張小小的**地圖（.lib）**來呼叫功能就好，不需要知道裡面發生了什麼事。\n\n**這就是為什麼不會把第三方原始碼直接丟進 UE：因為 DLL 讓你只需要連結它，而不需要伺候它。**\n\n寫得有點多，結論是所以這系列的文章會採用「**第三方函式庫 → Wrapper DLL → Unreal Plugin**」的分層架構，一步步的將製作過程記錄下來。\n\n### 📖 資料來源\n\n- **Microsoft 官方文件**：[連結器輸入檔 (.lib)](https://learn.microsoft.com/en-us/cpp/build/reference/dot-lib-files-as-linker-input)\n- **Unreal Engine 官方指南**：[整合第三方程式庫到 Unreal](https://dev.epicgames.com/documentation/en-us/unreal-engine/integrating-third-party-libraries-into-unreal-engine)\n- **UE 編譯架構**：[Unreal Build Tool (UBT) 運作原理](https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-build-tool-in-unreal-engine)",
    "content_zh": "",
    "content_en": ""
}