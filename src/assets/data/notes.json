[
    {
        "title_zh": "【Unreal & DLL 實戰】第一篇：概念與系統設計",
        "title_en": "Unreal & DLL in Practice — Part 1: Concepts and System Design",
        "category": "Unreal Engine",
        "date": "2026-02-26",
        "author": "Annie Su",
        "readTime": "20 min read",
        "tags": [
            "DLL",
            "Unreal Engine",
            "PLUGIN"
        ],
        "summary": "這篇文章從實際踩雷經驗出發，說明什麼是 DLL，以及為什麼在 Unreal Engine Plugin 開發中，使用 DLL 是更可靠的做法。",
        "content": "故事開始於我嘗試把一個第三方函式庫直接塞進 Unreal Plugin，結果完全不意外，專案瞬間炸裂。\n\n那一刻我才真正意識到：如果要把外部庫整合進 Unreal，又不想讓整個專案變成依賴地獄，勢必要找一個更乾淨、穩定、可維護的方式。\n\n於是我開始研究把第三方程式碼包成 **Wrapper DLL**——用一組簡單的 C 風格介面，把 Unreal 與外部世界隔離開來。選擇 C 介面的原因很單純：**C ABI 穩定、跨編譯器與跨語言都比較友善。**這種做法不但能保留效能，也能把 ABI、例外處理、記憶體管理等高風險問題鎖在 DLL 裡，讓 Plugin 的生命週期更可控、部署更輕鬆。\n\n也因為這次的踩雷經驗，我決定做一個完整的練習專案，採用「**第三方函式庫 → Wrapper DLL → Unreal Plugin**」的分層架構。從理解 DLL 的角色、建立一個簡單的第三方測試函式庫、將其包成 DLL，到最後在 Unreal Engine 中建立 Plugin 並成功呼叫 DLL 裡的功能，完整走一遍乾淨整合的流程。\n\n讓我們開始吧。\n\n# 所以，到底甚麼是 DLL?\n\n動態連結函式庫（Dynamic-Link Library，簡稱 **DLL**）是 Windows 用來封裝與共享程式碼的一種機制。你在電腦裡常看到的 `.dll`、`.ocx`、`.drv`，本質上都是同一類型的模組。\n\n它的核心概念其實很單純：**把可以重複使用的功能獨立編譯成一個檔案，需要時再由應用程式載入使用，而不必每個程式都複製一份。**\n\n這麼做的好處：\n\n- **節省記憶體與磁碟空間** —— 多個程式可以共用同一份程式碼。\n- **集中管理更新** —— 修正 DLL 的問題後，所有使用它的程式都能使用新的 DLL。\n\n如果要打個比方，DLL 有點像圖書館裡的一本書，很多人可以同時閱讀同一本書，就像很多程式可以同時載入同一個 DLL。\n\n不同的是，在看書的過程中，每個人都會在自己的筆記本上做筆記。對應到電腦的世界，作業系統會讓不同應用程式**共享同一份 DLL 的程式碼區段**，但每個程式仍然擁有**自己的資料與執行狀態**。\n\n也就是說，雖然程式碼是共用的，但執行時的記憶體與變數都是彼此獨立的。\n\n不過 DLL 也不是沒有缺點。早期的 Windows 因為缺乏完善的版本管理機制，只要多個軟體共用同一個 DLL，就很容易因為**版本不相容**、**安裝程式覆蓋掉系統 DLL**，或是**路徑解析錯誤**，讓原本運作正常的程式突然整批掛掉。這種因 DLL 共用而引發的連鎖災難，有一個非常貼切的名字： [DLL地獄（DLL Hell）](https://zh.wikipedia.org/zh-tw/DLL%E5%9C%B0%E7%8D%84)。\n\n## 有動態函示庫，那有靜態的嗎?\n\n既然有 DLL（動態連結函式庫），那也會有**靜態函式庫（Static Library）**。在 Windows 世界裡，它通常是 `.lib` 檔；在 Linux 則是 `.a` 檔。兩者最大的差別在於**程式碼是在什麼時候被放進你的應用程式裡**。\n\n靜態函式庫的運作方式很直接：在編譯階段，編譯器會把 `.lib` 裡需要的程式碼直接複製到你的可執行檔或 DLL 裡。這代表：\n\n- **編譯後的程式不需要額外的外部檔案，**給一個 `.exe` 就能跑。\n- 可執行檔會變大，且更新函式庫時需要重新編譯整個專案。\n\n> 💡 **想像你正在編寫一本書，而「函式庫」就是你引用的參考資料：**\n> \n\n### 靜態函式庫 (Static Lib)：影印店模式\n\n這就像是你去影印店，把整本參考書**全部複印下來，直接裝訂進你的書背後**。\n\n- **優點**：讀者買了你的書，翻到後面就能看資料（不需要額外帶書，部署簡單）。\n- **缺點**：你的書會變得很厚很重（執行檔變大）；如果原稿內容更新了，你得整本重新複印並重新裝訂（重新編譯整個專案）。\n\n### 動態函式庫 (DLL)：圖書館標註模式\n\n這就像是你只在書裡寫了一行註解：「請參考某某圖書館的某某書第 100 頁」。\n\n- **優點**：你的書很輕薄，且如果圖書館更新了更正確的書籍，你的書內容也隨之「升級」（集中管理更新）。\n- **缺點**：如果讀者家附近沒有那個圖書館，或者圖書館把書搬走了，你的書就沒法讀了（路徑錯誤或 DLL 遺失，導致程式崩潰）。\n\n### 混合模式 (.lib + .dll)：隨書附贈的導航地圖\n\n當你同時擁有這兩者時，`.lib` 就像是**隨書附贈的導航地圖（或精確索引）**。\n你不需要影印整本書，但你隨書附上一張精確的地圖。這張地圖（.lib）在編譯時會告訴你的程式：「書（代碼）確實存在，它的名字叫 `XXX.dll`，裡面有這些功能」。\n\n結果就是編譯器很放心（因為有地圖證明書存在），執行時系統也很輕鬆（因為有地圖引導去哪裡借書）。\n\n| **特性** | **純靜態函式庫 (只有大 .lib)** | **混合模式：隱式動態連結(小 .lib + .dll)** | **純動態：顯式動態連結(只有 .dll)** |\n| --- | --- | --- | --- |\n| **白話比喻** | **「影印店」**：內容直接印在書裡 | **「導航地圖」**：拿著地圖去圖書館借書 | **「盲找」**：到圖書館才打聽書在哪 |\n| **連結時間** | **編譯時** (Build Time) | **編譯時** (對地圖) + **執行時** (載入書) | **執行時** (Runtime)完全由程式碼手動控制 |\n| **程式碼位置** | **嵌入**在 `.exe` 內部 | **獨立**存在於外部 DLL 檔案 | **獨立**存在於外部 DLL 檔案 |\n| **部署難度** | **極低**：只有一個檔案 | **中等**：須確保 DLL 跟著 .exe | **中等**：須確保 DLL 跟著 .exe |\n| **更新方式** | **必須重新編譯**整個專案 | **直接換 DLL** 即可更新 | **直接換 DLL** |\n| **記憶體佔用** | **較高**：每個程式都含複本 | **較低**：多個程式共用內存 | **最靈活**：不用時可動態卸載 |\n| **開發難易度** | **易**：直接呼叫函式 | **易**：直接呼叫，編譯器會檢查 | **難**：需手動查位址、寫指標 |\n| **Unreal 常用度** | 常用於小型工具類 Plugin | **最常用**：主流 SDK 整合方式 | 進階：驅動、加密或熱更新模組 |\n\n## 為什麼不直接把第三方原始碼放進 Unreal Engine？\n\n雖然直接把別人的原始碼（Source Code）丟進專案資料夾看起來最省事，但在 Unreal Engine 這種充滿各種自定義的巨集的重量級巨獸面前，這種做法就像是想把一台法拉利的引擎直接焊接在卡車上，結果通常是車毀人亡。\n\n### 1. 命名空間的相互衝突\n\nUnreal 定義了大量的全域巨集（例如 `check()`, `TEXT()`, `Verify()`）。如果第三方原始碼（例如 Boost 或 ffmpeg）也定義了同名函式，編譯器會噴出幾千個錯誤訊息，你得花好幾週去改別人的程式碼才能相容。\n\n### 2. UHT 的理解障礙\n\nUE 的反射系統（讓藍圖能讀取 C++）依賴 UHT 掃描標頭檔。但 UHT 並不是真正的編譯器，它看不懂現代 C++ 太複雜的模板（Template）或語法糖。直接塞進去，UHT 會直接報錯罷工。\n\n### 3. 編譯時間考量\n\nUE 本身已經夠大了。如果你把一個幾萬行的第三方庫塞進專案，每次你改一個小功能，編譯器可能都要重新檢查那些沒動過的第三方代碼。\n\n- **使用 DLL 的解法**：DLL 是**預編譯好的二進位檔案**。對 UE 來說，它就像一個「黑盒子」，不需要重新編譯，只需要「連結」它。這能節省你每天幾小時的等待時間。\n\n## 結論：DLL 是一種隔離牆\n\n在開發中，通常會把第三方原始碼封裝成 DLL，這本質上是在 Unreal 與外部程式碼之間蓋起一道防護牆：\n\n- **牆內（DLL 內部）：** 你愛怎麼寫就怎麼寫，語法再怪、跟 UE 命名衝突都沒關係，它是一個獨立運作的黑盒子。\n- **牆外（UE 專案）：** 透過那張小小的**地圖（.lib）**來呼叫功能就好，不需要知道裡面發生了什麼事。\n\n**這就是為什麼不會把第三方原始碼直接丟進 UE：因為 DLL 讓你只需要連結它，而不需要伺候它。**\n\n寫得有點多，結論是所以這系列的文章會採用「**第三方函式庫 → Wrapper DLL → Unreal Plugin**」的分層架構，一步步的將製作過程記錄下來。\n\n### 📖 資料來源\n\n- **Microsoft 官方文件**：[連結器輸入檔 (.lib)](https://learn.microsoft.com/en-us/cpp/build/reference/dot-lib-files-as-linker-input)\n- **Unreal Engine 官方指南**：[整合第三方程式庫到 Unreal](https://dev.epicgames.com/documentation/en-us/unreal-engine/integrating-third-party-libraries-into-unreal-engine)\n- **UE 編譯架構**：[Unreal Build Tool (UBT) 運作原理](https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-build-tool-in-unreal-engine)",
        "id": 10,
        "title": "Unreal & DLL in Practice — Part 1: Concepts and System Design",
        "slug": "unreal-dll-in-practice-part-1-concepts-and-system-design"
    },
    {
        "title_zh": "ST 2110 IP Video Workflow: Unreal Engine to AJA Kona IP via Rivermax",
        "title_en": "ST 2110 IP Video Workflow: Unreal Engine to AJA Kona IP via Rivermax",
        "category": "Unreal Engine",
        "date": "2026-02-23",
        "author": "Annie Su",
        "readTime": "5 min read",
        "tags": [
            "Nvidia Rivermax",
            "Unreal Engine"
        ],
        "summary_zh": "",
        "summary_en": "",
        "content_zh": "# [Nvidia Rivermax](https://developer.nvidia.com/networking/rivermax#section-learning-library)\n\nNVIDIA Rivermax 是一套專為 媒體串流、SMPTE ST 2110、超高解析度影像傳輸 設計的高效能網路 SDK。它利用 NVIDIA ConnectX NIC / BlueField DPU 的硬體加速能力，提供極低延遲、低 CPU 使用率、穩定無抖動的影像傳輸。Rivermax 是目前廣電、虛擬製作、LED 牆、AI 影像處理領域的核心技術之一。\n\nRivermax 是本專案中負責 SMPTE ST 2110 影像傳輸、硬體加速、PTP 同步與高效能資料流處理的核心技術，確保整個系統能以廣電級品質輸出/輸入多路高解析度影像。",
        "content_en": "",
        "id": 5,
        "title": "ST 2110 IP Video Workflow: Unreal Engine to AJA Kona IP via Rivermax",
        "summary": "本系統以 NVIDIA Mellanox ConnectX‑6 系列網路介面卡 與 NVIDIA Rivermax SDK 為核心，建置一條符合 SMPTE ST 2110 的專業級 IP 視訊傳輸流程。Unreal Engine 負責即時渲染影像，並透過 Rivermax 將影像以 ST 2110‑20格式送出；接收端採用 AJA Kona IP 進行視訊解碼與監看。\n整體訊號路由與來源切換則由 Cerebrum Broadcast Controller 透過 NMOS IS‑04 / IS‑05 進行統一管理與控制。",
        "content": "# 系統總覽\n\n本系統以 NVIDIA Mellanox ConnectX‑6 系列網路介面卡 與 NVIDIA Rivermax SDK 為核心，建置一條符合 SMPTE ST 2110 的專業級 IP 視訊傳輸流程。Unreal Engine 負責即時渲染影像，並透過 Rivermax 將影像以 ST 2110‑20格式送出；接收端採用 AJA Kona IP 進行視訊解碼與監看。\n整體訊號路由與來源切換則由 Cerebrum Broadcast Controller 透過 NMOS IS‑04 / IS‑05 進行統一管理與控制。\n\n[Using SMPTE 2110 with nDisplay | Unreal Engine 5.7 Documentation | Epic Developer Community](https://dev.epicgames.com/documentation/en-us/unreal-engine/using-smpte-2110-with-ndisplay)\n\n# Nvidia Rivermax\n\n# 系統架構圖\n\n本系統由三台主機構成，透過 10G 網路與管理交換器串聯，實現 ST 2110 視訊傳輸與 NMOS 控制整合：\n\n![image.png](image/5/image.png)\n\n## PC 1：Unreal Engine 渲染與 Rivermax 傳送端\n\n- 安裝 Unreal Engine 與 NVIDIA Rivermax SDK\n- 搭載 ConnectX‑6 Lx 網路卡，支援 ST 2110 訊號傳輸\n- 透過 10G DAC 線直接連接至接收端（PC 2），傳送 ST 2110‑20 / 22 視訊流\n\n| 元件 | 版本 |\n| --- | --- |\n| 作業系統 | Windows 10 Pro 22H2 |\n| Unreal Engine | Unreal Engine 5.6.1 |\n| NVIDIA Rivermax SDK | Rivermax_Windows_1.60.6 |\n| ConnectX‑6 Lx 驅動 | 3.10.25798.0 |\n| ConnectX‑6 Lx Firmware | 26.47.1026 |\n| MFT（Mellanox Firmware Tools） | WinMFT_x64_4_34_1_10 |\n\n<aside>\n💡\n\nConnect-X 6 限制：此系列 NIC 雖受支援，但在 Windows 上無法提供完整 PTP 精準度。 [[i]](https://dev.epicgames.com/documentation/en-us/unreal-engine/setting-up-smpte-2110-in-unreal-engine#supported-network-cards)\n\n</aside>\n\n## PC 2：AJA Kona IP 接收端\n\n- 搭載 AJA Kona IP 卡，支援 ST 2110 編解碼，接收/發送 ST 2110 流\n- 所取得的 ST 2110 訊號可以供 ZD 工具、AJA Control Room、OBS 等軟體接收與監看\n- 並可透過 NMOS 控制來源切換\n\n| 元件 | 版本 |\n| --- | --- |\n| 作業系統 | Windows 11 Pro 25H2 |\n| AJA Kona IP Driver | v17.0 |\n| AJA Control Room | v17.0 |\n| AJA Firmware | KonaIP s2110 - 2023/02/28 |\n\n## PC 3：Cerevrum Broadcast Controller 控制端\n\n- 執行 Cerevrum 控制軟體，並註冊至 NMOS Registry\n- 透過 IS‑05 協定控制 Kona IP 的接收來源\n- 連接至管理交換器（MGMT），與其他節點進行 NMOS 註冊與控制通訊\n\n🔗 網路連線概述\n\n- **10G DAC 直連：** PC 1 → PC 2，傳送 ST 2110 視訊流\n- **MGMT 管理交換器：** 三台主機皆連接至此交換器，用於 NMOS 控制與管理通訊\n\n# 安裝與設定流程\n\n## 安裝 ConnectX‑6 Lx 韌體更新\n\n1. 至 [mlxup-mft](https://network.nvidia.com/support/firmware/mlxup-mft/) 頁面，選擇相對應的版本並下載韌體更新工具。\n2. 至 [firmware-downloads](https://network.nvidia.com/support/firmware/firmware-downloads/) 頁面，下載所需要的韌體。\n3. [**Updating Firmware Using a Specific Image**](https://docs.nvidia.com/networking/display/mlxupfwutility#src-49167189_mlxupFirmwareUtilityUserGuide-UpdatingFirmwareUsingaSpecificImage)\n    \n    In order to update the firmware of all NVIDIA adapter cards using a specific firmware image, run the following command:\n    \n    ```bash\n    mlxup -i <file path>\n    ```\n    \n\n## 安裝 ConnectX‑6 Lx Windows 驅動程式 [WibOF-2](https://docs.nvidia.com/nvidia-connectx-6-lx-pcie-hhhl-ethernet-adapter-cards-user-manual.pdf)\n\n1. 至 [winof-2](https://network.nvidia.com/products/adapter-software/ethernet/windows/winof-2/) 頁面，這是 NVIDIA 官方的 Windows 驅動。\n2. 選擇對應作業系統的驅動程式，並下載。\n3. 執行並完成安裝，安裝完成後重開機。\n4. 安裝成功後會在工作管理員看到此網卡。\n    \n    ![image.png](image/5/f7bd6e4e-4dd0-4d97-b0a5-d6f13dba56e5.png)\n    \n\n## 安裝 Nvidia Rivermax\n\n1. 進入 [Rivermax Getting Start Page](https://developer.nvidia.com/networking/rivermax-getting-started) (需要登入並申請權限才能進入頁面)\n2. 從下載區瀏覽各個版本的 Realease Note，尋找符合自己網卡的版本，本專案使用 Rivermax_Windows_1.60.6。\n3. 跟著 Installation Guide 安裝，由於我們已經安裝完 WinOF-2 ，因此直接安裝 Rivermax。\n4. 使用**系統管理員身分**開啟命令提示字元，去到 Rivermax-<Version>-win64.msi 所放置的資料夾，執行以下指令：\n    \n    ```jsx\n    Rivermax-<Version>-win64.msi\n    ```\n    \n5. 會跳出安裝頁面：\n    \n    ![image.png](image/5/image%201.png)\n    \n6. 跟著安裝指示安裝並將電腦重開機。\n\n## [NVIDIA’s Rivermax SDK License](https://dev.epicgames.com/documentation/en-us/unreal-engine/setting-up-smpte-2110-in-unreal-engine#license)\n\n請至[官方網站](https://developer.nvidia.com/rivermax-development-licence-request)申請 Rivermax 開發授權。\n取得授權檔後，將其放置於 Rivermax DLL 所在目錄，系統預設會在該位置尋找授權檔。\n若希望將授權檔放在其他位置（例如網路磁碟機），可使用環境變數：`RIVERMAX_LICENSE_PATH` 指定自訂的授權檔路徑。\n\n## Unreal Rivermax 設定\n\n開啟以下 Plugin 並重啟 Unreal Editor。\n\n![image.png](image/5/f3e873c5-e214-474c-afdb-6b0ca9bdccbb.png)\n\n![image.png](image/5/6ac45fbc-0d42-4c59-9ec1-d22a178e4b2d.png)\n\n![image.png](image/5/c14ccf70-a316-45be-90f3-4215fbf8c5ce.png)\n\n[SMPTE 2110 UX Reference in Unreal Engine | Unreal Engine 5.6 Documentation | Epic Developer Community](https://dev.epicgames.com/documentation/en-us/unreal-engine/smpte-2110-ux-reference-in-unreal-engine?application_version=5.6)\n\n[SMPTE 2110 Media IO Workflows in Unreal Engine | Unreal Engine 5.6 Documentation | Epic Developer Community](https://dev.epicgames.com/documentation/en-us/unreal-engine/smpte-2110-media-io-workflows-in-unreal-engine?application_version=5.6)\n\n## **Troubleshooting SMPTE 2110**\n\n### Rainbow-colored Video When Opening RivermaxMediaSource\n\n若在開啟 **RivermaxMediaSource** 時看到「彩虹色（rainbow-colored）」影像，而這並非預期行為，請確認 ConnectX NIC 的 FLEX Parser 設定是否正確。\n\n1. 安裝 `mlxconfig`（[Mellanox Firmware Tools, MFT）](https://network.nvidia.com/products/adapter-software/firmware-tools/)。`mlxconfig` 是 Mellanox Firmware Tools（MFT）的一部分，用於查詢與設定 ConnectX NIC 的硬體參數。\n2. 驗證 FLEX Parser 設定\n    \n    使用系統管理員身分執行以下指令，確認兩個參數的輸出是否一致：\n    \n    ```jsx\n    mlxconfig.exe q | findstr \"FLEX_PARSER_PROFILE_ENABLE PROG_PARSE_GRAPH\"\n    ```\n    \n    [請確保這兩個參數的輸出內容完全一致。](https://dev.epicgames.com/community/api/documentation/image/65a2f86a-54c9-45df-a99a-f1d73229b093?resizing_type=fit)\n    \n    請確保這兩個參數的輸出內容完全一致。\n    \n    若不一致，可能導致 NIC 無法正確解析 RTP Header，造成影像呈現彩虹色或錯位。\n    \n3. 如不一致，請使用系統管理員身分執行以下指令查詢裝置名稱：\n    \n    ```jsx\n    mst status\n    ```\n    \n    如果服務未啟動，請輸入：\n    \n    ```jsx\n    mst start\n    ```\n    \n    然後再輸入 `mst status` 會看到類似下列輸出：\n    \n    ![image.png](image/5/image%202.png)\n    \n    圖中 mt4127_pciconf0 位置的值即為你的裝置名稱。\n    \n4. 填入你的裝置名稱，輸入下列指令更改設定：\n    \n    ```jsx\n    mlxconfig.exe -d <你的裝置名稱> set FLEX_PARSER_PROFILE_ENABLE=1\n    mlxconfig.exe -d <你的裝置名稱> set PROG_PARSE_GRAPH=1\n    mlxconfig.exe -d <你的裝置名稱> reset\n    ```\n    \n    如：\n    \n    ```jsx\n    mlxconfig.exe -d mt4127_pciconf0 set FLEX_PARSER_PROFILE_ENABLE=1\n    mlxconfig.exe -d mt4127_pciconf0 set PROG_PARSE_GRAPH=1\n    mlxconfig.exe -d mt4127_pciconf0 reset\n    ```\n    \n5. 更改完後輸入以下指令確認輸出：\n    \n    ```jsx\n    mlxconfig.exe q | findstr \"FLEX_PARSER_PROFILE_ENABLE PROG_PARSE_GRAPH\"\n    ```\n    \n\n# 後續研究方向\n\n## GPU Direct\n\n- 研究 Rivermax 與 GPUDirect 的整合方式，評估是否能讓影像資料直接在 GPU 與 NIC 之間傳輸，減少 CPU 介入。\n- 測試 Unreal Engine 在啟用 GPUDirect 時的延遲改善幅度，並確認不同 GPU/NIC/Driver 組合的相容性。\n\n## NMOS for Rivermax（IS‑04 / IS‑05）\n\n- 研究 Rivermax 是否能透過 NMOS API 與現有的 Broadcast Controller（如 Cerebrum、VSM、Evertz Magnum）進行自動化註冊與路由。\n- 建立 UE → NMOS → 2110 Receiver 的完整控制流程，讓 Unreal Engine 成為可被 NMOS 管理的「Sender Node」。\n- 評估是否能將 Unreal Engine 的 2110 Stream Metadata（Format、Framerate、Colorimetry）自動同步到 NMOS Registry。\n\n## ST 2022‑7 Seamless Switching\n\n- 研究 Unreal Engine + Rivermax 是否能同時輸出 **A/B 雙路 2110 Stream**，以支援 2022‑7 的無縫切換。\n- 測試接收端（如 AJA Kona IP、Grass Valley、Imagine、Sony）在 2022‑7 下的切換延遲與容錯能力。\n- 探索是否能在 UE 內部建立「雙編碼路徑」或「雙 NIC」架構，以支援高可靠度的 Live Production Pipeline。",
        "slug": "st-2110-ip-video-workflow-unreal-engine-to-aja-kona-ip-via-rivermax"
    }
]